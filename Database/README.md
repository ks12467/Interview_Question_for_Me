# Part 데이터베이스

### 질문 목록
* [데이터베이스와 파일 시스템의 차이는 무엇인가요?](#데이터베이스와-파일-시스템의-차이는-무엇인가요)
* [RDBMS와 NoSQL의 차이는 무엇인가요?](#rdbms와-nosql의-차이는-무엇인가요)
* [트랜잭션이란 무엇인가요?](#트랜잭션이란-무엇인가요)
* [트랜잭션의 ACID 특성을 설명해주세요](#트랜잭션의-acid-특성을-설명해주세요)
* [RDBMS vs NOSQL에 대해서 설명해주세요.](#rdbms-vs-nosql에-대해서-설명해주세요)
* [Redis에 대해서 간단히 설명해주세요.](#redis에-대해서-간단히-설명해주세요)
* [정규화에 대해서 설명해주세요.](#정규화에-대해서-설명해주세요)
* [반정규화에 대해서 설명해주세요.](#반정규화에-대해서-설명해주세요)
* [인덱스란 무엇이고, 장단점은 무엇인가요?](#인덱스index란-무엇이고-장단점은-무엇인가요)
* [클러스터형 인덱스와 비클러스터형 인덱스의 차이는 무엇인가요?](#클러스터형-인덱스와-비클러스터형-인덱스의-차이는-무엇인가요)
* [조인의 종류를 설명해보세요.](#조인의-종류를-설명해보세요)
* [서브쿼리와 조인의 차이는 무엇인가요?](#서브쿼리와-조인의-차이는-무엇인가요)
* [트랜잭션 격리 수준을 설명해주세요.](#트랜잭션-격리-수준4단계을-설명해주세요)
* [팬텀 리드란 무엇인가요?](#팬텀-리드phantom-read란-무엇인가요)
* [저장 프로시저란 무엇인가요?](#저장-프로시저란-무엇인가요)
* [트리거란 무엇인가요?](#트리거란-무엇인가요)
* [데이터베이스 락의 종류와 차이는 무엇인가요?](#데이터베이스-락의-종류와-차이는-무엇인가요)
* [교착상태는 무엇이며 해결 방법은 무엇인가요?](#교착-상태는-무엇이며-어떻게-해결하나요)
* [데이터베이스 샤딩이란 무엇인가요?](#데이터베이스-샤딩이란-무엇인가요)
* [데이터베이스 복제란 무엇인가요?](#데이터베이스-복제란-무엇인가요)
* [데이터베이스 파티셔닝이란 무엇인가요?](#데이터베이스-파티셔닝이란-무엇인가요)
---
## 데이터베이스와 파일 시스템의 차이는 무엇인가요?
데이터베이스는 데이터를 구조적으로 저장하고 관리하는 시스템이고, 파일 시스템은 단순히 데이터를 파일 단위로 저장하는 방식입니다.

파일 시스템은 데이터를 단순 저장하고 읽는 데 적합하지만, 동시성 제어, 데이터 무결성, 복구 기능이 부족합니다. 반대로 데이터베이스는 **[트랜잭션 관리(ACID)](#트랜잭션의-acid-특성을-설명해주세요), 동시성 제어, 데이터 무결성** 같은 가눙을 제공해 안정적인 데이터 처리를 보장합니다. 또한 인덱스를 통해 검색 속도를 높이고, 장애가 발생했을 때 복구할 수 있는 메커니즘도 갖추고 있습니다. 즉, 파일 시스템은 단순 스토리지 용도라면 충분하지만, 비즈니스 로직이 복잡하거나 여러 사용자가 동시에 접근하는 시스템에서는 데이터베이스가 필수적입니다.

예를 들어 은행 시스템을 생각해보면 파일 시스템에서는 두 명이 동시에 같은 계좌에서 출금을 시도할 때 데이터 불일치가 발생할 수 있습니다. 반면 데이터베이스에서는 트랜잭션이 적용되어 원자성과 일관성을 보장합니다. 또한 로그와 체크포인트 기반으로 장애 상황에서도 데이터를 복구할 수 있습니다. 즉 데이터베이스는 신뢰성과 성능을 동시에 확보하기 위한 시스템입니다.

---
## RDBMS와 NoSQL의 차이는 무엇인가요?
RDBMS는 관계형 모델 기반의 데이터베이스로, [스키마](../Programming%20Terminology/README.md#스키마)와 [SQL](../Programming%20Terminology/README.md#sql)을 사용합니다. NoSQL은 [비정형](../Programming%20Terminology/README.md#비정형-데이터), 대규모 데이터를 처리하기 위해 등장한 비관계형 데이터베이스입니다.

RDBMS는 정규화된 테이블 구조와 SQL을 사용해 데이터를 관리하며, [트랜잭션](#트랜잭션이란-무엇인가요)과 데이터 무결성을 보장합니다. 반면 NoSQL은 스키마가 유연하고 [JSON](../Programming%20Terminology/README.md#json), [Key-Value](../Programming%20Terminology/README.md#key-value), [Column](../Programming%20Terminology/README.md#column), [Graph](../Programming%20Terminology/README.md#graph) 등 다양한 형태로 데이터를 저장할 수 있어 확장성이 뛰어납니다. 따라서 RDBMS는 은행.ERP처럼 정확성과 무결성이 중요한 곳에서 사용되고, NoSQL은 SNS, 로그 데이터, IoT처럼 대규모 데이터를 빠르게 처리하고 확장해야 하는 환경에서 강점을 가집니다.

---
## 트랜잭션이란 무엇인가요?
트랜잭션은 데이ㅏ터베이스에서 하나의 논리적 작업 단위를 의미합니다.

트랜잭션은 여러 작업을 하나로 묶어 처리하여, 전부 성공하거나 전부 실패하도록 보장합니다. 이는 데이터 무결성을 유지하기 위해 중요하며, ACID(원자성, 일관성, 격리성, 지속성) 특성을 따릅니다. 예를 들어 은행 송금에서 출금과 입금은 반드시 함께 성공하거나 함께 실패해야 하며, 이과정을 보장하는 것이 트랜잭션입니다.

---
## 트랜잭션의 ACID 특성을 설명해주세요.
ACID는 데이터베이스 트랜잭션이 가져야 하는 4가지 핵심 특성을 말합니다. 이 성질을 통해서 안전하게 수행된다는 것을 보장합니다.<br/>
원자성은 트랜잭션의 모든 작업이 전부 성공하거나 전부 실패해야 합니다.<br/>
일관성은 트랜잭션 수행 전과 수행 후에 데이터베이스가 항상 유효한 상태를 유지해야 합니다.<br/>
격리성은 동시에 실행되는 트랜잭션들이 서로의 작업에 영향을 주지 않도록 독립적으로 실행되어야 합니다.<br/>
지속성은 트랜잭션 성공적으로 완료되면 그 결과가 영구적으로 저장되어, 시스템 오류가 발생하더라도 데이터가 유지되어야 합니다.

> #### [참고]
> 일관성에 대해 보충하자면 트랜잭션이 실행되기 전과 후에 데이터베이스가 제약 조건을 만족하며 일관된 상태를 유지해야 한다는 원칙입니다.<br/>
> 즉, 데이터베이스의 무결성 제약 조건(예: 유효하지 않은 데이터는 저장되지 않음)을 항상 만족해야 합니다.<br/>
> 얘를 들어, 계좌 이체 시 한 계좌에서 돈이 출금되면 다른 계좌에는 반드시 입금되어야 합니다. 어느 한 쪽만 변경되고 다른 쪽은 변경되지 않으면 일관성이 깨진 상태가 됩니다. 

---
## RDBMS vs NOSQL에 대해서 설명해주세요.
RDBMS는 관계형 데이터베이스 관리 시스템으로, 데이터를 2차원 테이블 구조로 저장하고 외래 키를 통해 테이블 간의 관계와 Join을 지원하는 것이 특징입니다. 정합성과 ACID 트랜잭션 보장이 강점이지만, 확장성 측면에서는 주로 Scale-Up 방식만 지원합니다.<br/>
반면 NoSQL은 테이블 간 관계를 정의하지 않고, 문서, 키-값, 그래프, 컬럼형 등 다양한 모델을 지원합니다. 수평적 확장(Scale-Out)이 쉽고, 빅데이터나 대규모 트래픽 환경에서 유리하지만 데이터 정합성은 RDBMS보다 약할 수 있습니다.
즉, RDBMS는 안정성과 일관성, NoSQL은 확장성과 유연성에 초점을 둔다고 정리할 수 있습니다.
둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 

---
## Redis에 대해서 간단히 설명해주세요.
Redis는 인메모리 기반의 키-값 데이터 저장소로 매우 빠른 읽기/쓰기 성능을 제공하는 DB 입니다.<br/>
데이터를 디스크가 아닌 메모리에 저장하기 때문에 빠른 응답 속도를 보장하며, 문자열, 해시, 리스트, 집합과 같은 자료구조를 지원합니다.<br/>
주로 캐싱, 세션 관리, 실시간 랭킹, Pub/Sub 메시지 브로커, 분산락 등 빠른 응답이 필요한 영역에서 활용됩니다. 또한 단일 스레드 기반이지만 이벤트 루프 방식으로 고성능을 유지하며, 클러스터링을 통해 확장할 수 있습니다.

> #### [참고]
> Redis는 인메모리 기반?<br/>
> - 데이터를 디스크가 아닌 Redis 서버가 실행되는 머신의 RAM에 저장한다는 의미입니다. 애플리케이션 입장에서는 네트워크로 접근하기 때문에 외부 DB 처럼 보이지만, 내부적으로는 RAM을 활용해 초고속 성능을 낼 수 있습니다.<br/>
> 
> 이벤트 루프 방식?<br/>
> - 하나의 작업이 끝나고 나서 다른 하나를 시작하는 것이 아닌, 입출력 같은 작업은 비동기로 요청만 등록하고, 실제 응답이 도착할 때까지 기다리지 않습니다. CPU는 그 시간에 다른 요청을 계속 처리합니다. 그래서 마치 여러 요청이 동시에 처리되는 것처럼 보이지만, 실제로는 한 스레드가 논블로킹 방식으로 빠르게 컨텍스트 전환을 하는 것입니다.<br/> 
> - 논블로킹과 비동기 차이 : https://www.youtube.com/watch?v=cmBFGSrHKnM&t=162s <br/>
> 
> 클러스터링을 통한 확장?<br/>
> - 기본적으로 Redis는 싱글 스레드입니다. 그래서 하나만 띄우면 CPU 코어도 1개 밖에 못 쓰기 때문에 병렬성 한계가 있습니다. 그래서 싱글 스레드인 Redis 인스턴스를 여러개 띄워서 클러스터링 하면 멀티스레드처럼 병렬 처리하는 것처럽 보입니다.

---
## 정규화에 대해서 설명해주세요.
정규화는 데이터베이스 설계에서 데이터 중복을 최소화하고, 일관성을 유지하기 위해 테이블을 구조화하는 과정을 말합니다.<br/>
주 목적은 중복으로 인한 저장 공간 낭비와 이상 현상을 방지하는 것입니다. 일반적으로 1정규형, 2정규형, 3정규형과 같이 단계별로 나누어 설계하며, 각 단계마다 테이블을 분리하거나 속성을 이동시켜 데이터 구조를 개선합니다.<br/>
정규화를 통해 데이터 무결성을 확보할 수 있지만, 조인이 많아져 조회 성능이 저하 될수 있기에 상황에 따라 반정규화와 정규화를 균형있게 고려해야 합니다.<br/>

> #### [참고]
> 이상현상?
> - 삽입이상: 새로운 데이터를 삽입할 때, 의도하지 않는 다른 정보까지 함께 삽입해야만 하는 경우
> - 삭제이상: 데이터를 삭제할 때, 의도하지 않은 다른 정보까지 함께 삭제되는 경우
> - 갱신이상: 중복된 데이터를 수정할 때, 일부만 수정되어 데이터 불일치가 발생하는 경우
> 
> 데이터 무결성은 데이터가 생성된 시점부터 사용되는 전체 라이프사이클 동안 정확성, 완전성, 일관성, 신뢰성을 유지하고 승인 없이 변경되지 않도록 보장하는 특성입니다.
> 정규화 단계 정리 필요

---
## 반정규화에 대해서 설명해주세요
반정규화(Denormalization)는 정규화를 거쳐 분리된 테이블을 다시 합치거나 중복을 허용하여 성능을 개선하는 기법입니다.

정규화는 중복을 줄여 무결성을 보장하지만, 과도한 정규화는 조인 비용을 증가시켜 성능 저하를 일으킵니다. 이때 반정규화를 통해 일부 데이터를 중복 저장하거나 테이블을 합쳐 조회 성능을 높일 수 있습니다. 주롷 데이터 조회가 빈번하고 실시간 응답이 중요한 환경에서 활용됩니다. 다만 반정규화는 데이터 중복으로 인해 수정 시 불일치가 발생할 수 있어 관리 비용이 커집니다.

예를 들어 전자상거래에서 주문 내역을 조회할 때, 주문 테이블과 상품 테이블을 매번 조인하면 속도가 느려질 수 있습니다. 이를 해결하기 위해 주문 테이블에 상품명을 직접 저장해두면 조회 성능은 빨라지지만, 상품명ㅇ이 변경될 때 모든 주문 데이터도 갱신해야 하는 문제가 생깁니다. 따라서 반졍규화는 무조건적인 해결책이 아니라, 읽기 성능 최적화와 데이터 일관성 사이에서 트레이드오프를 고려한 선택입니다.

---
## 인덱스(Index)란 무엇이고, 장단점은 무엇인가요?
인덱스는 테이블의 특정 컬럼에 대해 빠른 검색을 가능하게 해주는 자료구조입니다.

인덱스는 주로 [B-Tree](../Programming%20Terminology/README.md#b-tree) 또는 [Hash](../Programming%20Terminology/README.md#hash) 구조로 구현되며, 데이터 검색 속도를 크게 향상시킵니다. 예를 들어 WHERE, JOIN, ORDER BY 절에서 효과적입니다. 하지만 인덱스는 추가적인 저장 공간을 필요로 하고, 데이터 삽입, 수정, 삭제 시 인덱스도 갱신해야 하므로 쓰기 성능은 떨어집니다. 따라서 모든 컬럼에 인덱스를 걸 수 없고, 조회 빈도와 쓰기 빈도를 고려해 전략적으로 사용해야 합니다.

---
## 클러스터형 인덱스와 비클러스터형 인덱스의 차이는 무엇인가요?
클러스터형 인덱스는 테이블의 데이터를 인덱스 순서대로 정렬하여 저장하고, 비클러스터형 인덱스는 인덱스와 실제 데이터가 분리되어 있는 방식입니다.

클러스터형 인덱스는 테이블 자체가 인덱스 구조를 따르기 때문에 검색 속도가 빠르지만, 한 테이블에 하나만 설정이 가능합니다. 반면 비클러스터형 인덱스는 별도의 구조로 존재하여 여러 개를 만들 수 있지만, 검색 시 실제 데이터 위치를 찾아가는 추가 작업이 필요합니다. 따라서 클러스터형은 PK 같은 주 검색 키에, 비클러스터형은 자주 조회되는 보조 키에 적합합니다.

> 참고
> MySQL InnoDB에서는 기본적으로 PK가 클러스터형 인덱스로 설정됩니다.
> 따라서 PK 조회는 매우 빠르지만 PK 변경은 테이블 전체를 재정렬해야 하므로 성능 비용이 큽니다.
> 반대로 보조 인덱스인 비클러스터형은 특정 WHERE 절 검색에서 성능을 높여주지만, 커버링 인덱스가 아니라면 실제 데이터 페이지를 한 번 더 접근해야 합니다. 

---
## 조인의 종류를 설명해보세요.
조인은 두 개 이상의 테이블을 결합하여 데이터를 조회하는 방법입니다.

대표적인 조인은 INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN, CROSS JOIN 등이 있습니다. INNER JOIN은 공통된 값이 있는 행만, LEFT JOIN은 왼쪽 테이블의 모든 행과 매칭되는 오른쪽 데이터를 반환합니다. FULL OUTER JOIN은 두 테이블의 모든 행을 반환합니다. CROSS JOIN은 모든 조합을 반환합니다.

예를 들어 고객 테이블과 주문 ㄷ테이블을 조인할 때, INNER JOIN은 실제 주문한 고객만 나오지만 LEFT JOIN은 주문하지 않은 고객도 함께 조회됩니다. 대규모 데이터에서 조인은 성능을 크게 좌우하므로, 인덱스 설계와 쿼리 최적화가 필수입니다.

---
## 서브쿼리와 조인의 차이는 무엇인가요?
서브쿼리는 쿼리 안에 또 다른 쿼리를 중첩하여 사용하는 방식이고, 조인은 여러 테이블을 결합하는 방식입니다.

서브쿼리는 특정 조건에 맞는 데이터를 가져오는 데 직관적이고 간단하지만, 성능상 비효율적일 수 있습니다. 조인은 서브쿼리보다 성능이 좋은 경우가 많고, 실행 계획에서도 더 최적화되기 쉽습니다. 따라서 단순 조건 필터링에는 서브쿼리를, 복잡한 데이터 결합에는 조인을 주로 사용합니다.

예를 들어 주문 금액이 가장 높은 고객을 구할 때 서브쿼리를 사용하면 간단히 작성할 수 있습니다. 하지만 대규모 데이터에서 서브쿼리는 중첩 실행으로 성능 저하를 일으킬 수 있습니다.

---
## 트랜잭션 격리 수준(4단계)을 설명해주세요.
트랜잭션 격리 수준은 동시에 실행되는 트랜잭션 간에 데이터 접근 방식을 정의하는 규칙입니다.

격리 수준은 [READ UNCOMMITTED](../Programming%20Terminology/README.md#read-uncommitted), [READ COMMITTED](../Programming%20Terminology/README.md#read-committed), [REPEATABLE READ](../Programming%20Terminology/README.md#repeatable-read), [SERIALIZABLE](../Programming%20Terminology/README.md#serializable) 네 가지가 있습니다. READ UNCOMMITTED는 커밋되지 않은 데이터도 읽을 수 있어 DIRTY READ가 발생합니다. READ COMMITTED는 커밋된 데이터만 읽지만 Non-Repeatable Read 문제가 있습니다. REPEATABLE READ는 동일 트랜잭션 내 같은 데이터를 항상 동일하게 보장합니다 SERIALIZABLE은 가장 높은 격리 수준으로 모든 트랜잭션을 직렬화해 실행합니다.

* 보충 설명 필요

---
## 팬텀 리드(Phantom Read)란 무엇인가요?
팬텀 리드는 트랜잭션 중에 같은 조건으로 두 번 이상 조회했을 때, 중간에 다른 트랜잭션이 데이터를 삽입하거나 삭제하여 결과 행의 개수가 달라지는 현상입니다.

첫 번째 SELECT애서 10개의 행이 조회되었는데, 다른 트랜잭션이 새로운 행을 삽입한 후 같은 조건으로 다시 SELECT 하면 11개가 나오는 상황입니다. 이는 REPEATABLE READ 수준에서도 발생할 수 있으며, SERIALIZABLE 수준에서만 완전히 방지됩니다. 따라서 팬텀 리드는 트랜잭션의 일관성을 깨뜨릴 수 있는 중요한 문제입니다. 

---
## 저장 프로시저란 무엇인가요?
저장 프로시저는 미리 작성된 SQL 문을 데이터베이스에 저장해두고 필요할 때 호출하여 실행할 수 있는 프로그램입니다.

저장 프로시저는 복잡한 로직을 재사용 가능하게 하고, 네트워크 트래픽을 줄이며, 보안성을 높일 수 있습니다. 그러나 DBMS에 종속적이고, 로직이 DB에 집중되면 관리가 어려워질 수 있습니다. 따라서 비즈니스 로직은 애플리케이션에 두고, 반복적인 데이터 처리 작업에 주로 사용합니다.

예를 들어, 급여 계산이나 대량 데이터 배치 처리를 저장 프로시저로 구현하면 애플리케이션에서 동일한 SQL을 반복 작성하지 않아도 됩니다. 하지만 저장 프로시저는 DB 부하를 증가시키고, 특정 DBMS에 종속되므로 이식성이 떨어집니다. 최근 MSA 환경에서는 저장 프로시저보다는 애플리케이션 코드에서 처리하는 경우가 많습니다.

---
## 트리거란 무엇인가요?
트리거는 특정 이벤트(INSERT, UPDATE, DELETE)가 발생했을 때 자동으로 실행되는 SQL 구문입니다.

트리거는 데이터 무결성 보장, 로깅, 자동 검증 등에 유용합니다. 하지만 남용하면 성능 저하와 디버깅 어려움이 생길 수 있습니다.

트리거는 데이터 변경을 자동화할 수 있어 편리하지만, 복잡한 트리거 체인은 성능 문제와 예측 불가능한 동작을 유발합니다. 또한 트리거는 숨겨진 로직처럼 동작해 개발자가 문제를 파악하기 어렵습니다.

---
## 데이터베이스 락의 종류와 차이는 무엇인가요?
락은 동시에 여러 트랜잭션이 같은 데이터를 접근할 때 충돌을 방지하기 위한 메커니즘입니다.

락은 크게 공유 락(Shared Lock)과 베타 락(Exclusive Lock)으로 나뉩니다. 공유 락은 여러 트랜잭션이 읽기는 가능하지만 쓰기는 불가능합니다. 베타 락은 한 트랜잭션만 해당 데이터를 읽고 쓸 수 있습니다. 또한 테이블 락과 행 락으로 구분되며, 행 락은 동시성을 높여 성능이 향상됩니다.

예를 들어 A 트랜잭션이 공유 락을 걸면 다른 트랜잭션도 읽을 수 있지만, 베타 락이 걸리면 접근이 불가능합니다. MySQL InnoDB는 기본적으로 **행 단위 락(Row-Level Lock)** 을 사용해 동시성을 높입니다. 하지만 대량 UPDATE나 잘못된 인덱스 사용 시 행 락이 테이블 락으로 승격되어 성능 병목이 발생할 수 있습니다. 이러한 문제를 하기 위해서는 락 타임아웃 설정과 쿼리 최적화를 통해 이런 문제를 예방할 수 있습니다.

---
## 교착 상태는 무엇이며 어떻게 해결하나요?
교착 상태는 두 개 이상의 트랜잭션이 서로가 가진 자원을 기다리면서 무한 대기 상태에 빠지는 현상입니다.

교착 상태는 상호 배제, 점유 대기, 비선점, 순환 대기의 4가지 조건이 모두 충족될 때 발생합니다. 이를 해결하기 위해 예방(조건 차단), 회피, 탐지 및 회복을 사용합니다.

예방은 교착 상태 발생 조건 중 하나를 제거하는 방법이고, 회피는 자원 할당 시 교착 상태가 발생하지 않도록 미리 판단하는 방법입니다. 탐지 및 회복은 교착 상태를 감지한 후 트랜잭션을 강제 종료하거나 자원을 회수하는 방법입니다.

---
## 데이터베이스 샤딩이란 무엇인가요?
샤딩은 대규모 데이터를 여러 데이터베이스 서버에 분산하여 저장하고 처리하는 기법입니다.

샤딩은 수평 분할의 일종으로, 데이터베이스의 확장성과 처리 성능을 높입니다. 샤딩 키를 기준으로 데이터를 나누어 각 샤드에 분산 저장합니다. 이를 통해 단일 서버의 부하를 줄이고, 읽기/쓰기 성능을 향상시킬 수 있습니다. 그러나 샤딩은 데이터 일관성 유지, 복잡한 쿼리 처리, 관리 오버헤드 증가 등의 단점도 있습니다.

샤딩은 대규모 서비스에서 필수적인 확장 전략입니다. 예를 들어, 사용자 ID를 기준으로 샤딩하면 특정 사용자의 데이터를 빠르게 조회할 수 있습니다. 하지만 조인이 필요한 복잡한 쿼리는 여러 샤드를 동시에 접근해야 하므로 성능 저하가 발생할 수 있습니다. 따라서 샤딩 설계 시 데이터 액세스 패턴을 면밀히 분석하고, 적절한 샤딩 키를 선택하는 것이 중요합니다.

---
## 데이터베이스 복제란 무엇인가요?
복제는 하나의 데이터베이스에서 변경된 데이터를 다른 데이터베이스 서버로 동기화하는 기술입니다.

복제는 주로 마스터-슬레이브 구조로 이루어지며, 읽기 부하 분산과 장애 복구를 위해 사용됩니다. 마스터는 쓰기와 읽기를 모두 수행하고, 슬레이브는 읽기만 수행합니다. 이를 통해 성능과 가용성을 동시에 확보할 수 있습니다.

복제는 데이터 일관성 유지, 네트워크 지연, 복제 지연 등의 문제를 야기할 수 있습니다. 특히 비동기 복제에서는 마스터와 슬레이브 간 데이터 불일치가 발생할 수 있습니다. 따라서 복제 설정 시 일관성 요구사항과 성능 요구사항을 균형 있게 고려해야 합니다.

---
## 데이터베이스 파티셔닝이란 무엇인가요?
파티셔닝은 하나의 큰 테이블을 여러 개의 작은 테이블로 나누어 관리하는 기법입니다.

파티셔닝은 관리 효율성과 성능을 높이기 위해 사용됩니다. 범위 파티셔닝, 해시 파티셔닝, 리스트 파티셔닝 등이 있으며, 특정 컬럼 값에 따라 데이터를 나눕니다. 하지만 지나친 파티셔닝은 쿼리 복잡도를 높이고 관리 비용이 증가합니다.

파티셔닝은 대규모 테이블에서 성능 최적화에 효과적입니다. 예를 들어, 날짜별로 파티셔닝하면 특정 기간의 데이터만 빠르게 조회할 수 있습니다. 그러나 파티셔닝된 테이블 간 조인이 필요할 때는 성능 저하가 발생할 수 있으므로, 파티셔닝 전략을 신중히 설계해야 합니다.
