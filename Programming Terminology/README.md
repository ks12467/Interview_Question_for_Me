# 프로그래밍 용어 정리

### CTRL + F를 사용해 용어 목록에서 찾는걸 권장드립니다.

---
## 용어 목록

* [프로세스](#프로세스)
* [스레드](#스레드)
* [PCB(Process Control Block)](#pcb)
* [TCB(Thread Control Block)](#tcb)
* [TLB(Translation Lookaside Buffer)](#tlb)
* [I/O(Input/Output)](#io)
* [IPC 기법](#ipc-기법)
* [인터럽트](#인터럽트)
* [Race Condition](#race-condition)
* [임계구역](#임계구역)
* [상호배제](#상호배제)
* [진행](#진행)
* [유한 대기](#유한대기)
* [뮤텍스](#뮤텍스)
* [세마포어](#세마포어)
* [모니터](#모니터)
* [DB 트랜잭션 격리 수준](#db-트랜잭션-격리-수준)
* [기아 상태](#기아-상태)
* [Aging 기법](#aging-기법)
* [라운드 로빈](#라운드-로빈)
* [가상 메모리](#가상-메모리)
* [페이지 테이블](#페이지-테이블)
* [가상 주소와 물리 주소](#가상-주소와-물리-주소)
* [페이지 폴트](#페이지-폴트)
* [JVM](#jvm)
* [힙 메모리](#힙-메모리)
* [스택 메모리](#스택-메모리)
* [GC](#gc)
* [OOM](#oom)
* [스왑공간](#스왑-공간)
* [캐시](#캐시)
* [지역성](#지역성)
* [페이징](#페이징)
* [세그먼테이션](#세그먼테이션)
* [스레싱](#스레싱)
* [워킹 셋 모델](#워킹-셋-모델)
* [폴링](#폴링)
* [커널 모드](#커널-모드)
* [사용자 모드](#사용자-모드)
* [LRU](#lru)
* [LFU](#lfu)
* [FIFO](#fifo)
* [Optimal](#optimal)
* [스키마](#스키마)
* [SQL](#sql)
* [NoSQL](#nosql)
* [비정형](#비정형-데이터)
* [JSON](#json)
* [Key-Value](#key-value)
* [Column](#column)
* [Graph](#graph)
* [B-tree](#b-tree)
* [Hash](#hash)
* [READ UNCOMMITTED](#read-uncommitted)
* [READ COMMITTED](#read-committed)
* [REPEATABLE READ](#repeatable-read)
* [SERIALIZABLE](#serializable)
* 

---

## 프로세스
실행 중인 프로그램의 독립적인 실행 단위

독립된 메모리 공간을 보유함.<br>
다른 프로세스와 메모리 공유 안함 <br>
생성. 전환이 느리지만 안정성이 높음 <br>
OS가 [PCB](#pcb)로 상태 관리

---
## 스레드
프로세스 내부에서 실행되는 흐름 단위

같은 프로세스의 Code, Data, Heap 공유 / Stack은 개별적<br>
생성과 전환이 빠르고 통신이 쉬움<br>
동기화 필요 (Race Condition 가능성이 있음)<br>
OS가 [TCB](#tcb)로 상태 관리

---
## PCB
PCB = Process Control Block의 약자로 프로세스의 모든 상태 정보를 담고 있는 자료 구조


포함 내용
* PID (Process ID, 고유 식별자)
* 프로세스 상태
* 프로그램 카운터
* CPU 레지스터 값
* 메모리 정보 (Code/Data/Stack 세그먼트)
* 입출력 상태, 열린 파일 정보 등

프로세스 하나당 PCB 하나 존재

---
## TCB
TCB = Thread Control Block의 약자로 스레드의 실행 상태를 담고 있는 자료구조

포함 내용
* TID (Thread ID, 고유 식별자)
* 스레드 상태
* 프로그램 카운터
* CPU 레지스터 값
* 스레드 스택 정보
* 스레드 우선순위

스레드는 프로세스 자원을 공유하므로, TCB는 스레드 고유 정보만 따로 가짐

스레드 하나당 TCB 하나 존재

---
## TLB
TLB = Translation Lookaside Buffer의 약자로 CPU 안에 있는 아주 빠른 캐시로, 가상 메모리 주소를 실제 물리 메모리 주소로 바꿀 때 속도를 높여주는 장치.

자주 쓰는 일부를 미리 저장해두는 초고속 메모리

---
## I/O
Input/Output의 줄임말

---
## IPC 기법
Inter-Process Communication 즉 프로세스 간 통신을 말한다.

운영 체제에서 독립된 프로세스들이 데이터를 주고받거나 작업을 동기화하기 위해 사용하는 방법.

---
## 인터럽트
Interrupt란? CPU가 하던 일을 잠시 멈추고, 다른 중요한 일을 먼저 처리하게 하는 신호

즉, 예외 상황이나 이벤트가 발생했음을 CPU에 알리는 메커니즘

---
## Race Condition
Race Condition 경쟁 상태란 둘 이상의 프로세스나 스레드가 동시에 같은 자원에 접근해서, 실행 순서에 따라 결과가 달라지는 상황을 말합니다.

---
## 프로세스 동기화
여러 프로세스 또는 스레드가 공유 자원에 접근할 때, 데이터의 일관성과 정확성을 보장하도록 실행 순서를 제어하는 것

동기화가 없으면 [Race Condition](#race-condition) 발생 -> 실행 순서에 따라 결과가 달라짐<br>
공유 자원 접근을 제어하는 영역을 임계 구역이라고 함<br>
해결 방법 조건을 만족해야 함<br>
동기화 도구로는 뮤텍스, 세마포어, 모니터 등이 있음<br>
OS에서 프로세스 스케줄링, 데이터 일관성 유지, Deadlock 방지 등에 필수

---
## 임계구역
여러 프로세스나 스레드가 동시에 접근하면 안되는 공유 자원에 접근하는 코드 영역<br>
데이터의 일관성과 무결성을 보장하기 위해 한 번에 하나의 실행 흐름만 접근해야 함

---
## 상호배제
여러 프로세스나 스레드가 동시에 임계 구역에 들어가지 모사게 하여, 한 시점에 단 하나의 실행 흐름만 공유 자원에 접근하도록 보장하는 원칙


---
## 진행
임계 구약에 아무도 들어가 있지 않을 때, 들어가길 원하는 프로세스/스레드 중에서 누군가는 반드시 진입 결정을 낼릴 수 있어야 한다는 원칙

---
## 유한대기
임계 구역에 들어가길 원하는 프로세스 또는 스레드가 무한히 기다리지 않도록 보장하는 기아 방지 조건

---
## 뮤텍스
상호 배제를 위한 잠금 도구<br>
한 번에 하나의 스레드/프로세스만 임계 구역 진입 가능

---
## 세마포어
동기화 및 접근 개수 제어를 위한 카운터 기반 도구<br>
count 값으로 동시에 접근 가능한 실행 흐름 수를 제한

---
## 모니터
언어 차원에서 제공하는 동기화 메커니즘<br>
임계 구역 접근과 조건 변수를 함께 제공

---
## DB 트랜잭션 격리 수준
동시에 여러 트랜잭션이 실행될 때, 서로의 작업이 얼마나 영향을 미치는지를 제어하는 단계<br>
격리 수준이 높을수록 데이터 일관성 상승, 동시성 하락

***격리 수준 관련 내용 추가 필요**

---
## 기아 상태
특정 프로세스 또는 스레드가 필요한 자원을 계속 할당받지 못해 무한히 대기하는 상태<br>
자원 할당의 불공평한 스케줄링이나 우선순위 정책 때문에 발생

---
## Aging 기법
우선순위 스케줄링에서 낮은 우선순위 프로세스가 기아 상태에 빠지지 않도록, 대기 시간이 길어질수록 우선순위를 조금씩 높여주는 기법

---
## 라운드 로빈
선점형(Preemptive) CPU 스케줄링 알고리즘 중 하나<br>
고정된 시간 할당량 동안 CPU를 사용하고, 시간이 끝나면 대기 큐의 맨 위로 이동<br>
모든 프로세스에 CPU 사용 기회를 공평하게 제공

---
## 가상 메모리
실제 물리 메모리 크기에 관계없이, 프로세스가 큰 연속된 메모리를 쓰는 것처럼 제공하는 메모리 관리 기법<br>
주소 변환을 통해 가상 주소를 실제 물리 주소로 매핑

---
## 페이지 테이블
가상 메모리에서 가상 주소의 페이지 번호를 물리 메모리의 프레임 번호로 변환하는 매핑 정보 구조.<br>
각 엔트리는 유효 비트(Valid), 수정 여부(Dirty), 참조 여부(Access) 등의 플래그를 가지고 있으며, 주소 변환 과정은 가상 주소 -> 페이지 번호 -> 프레임 번호 + 오프셋 -> 물리 주소 순으로 진행된다.<br>
성능 향상을 위해 페이지 테이블을 개싱하는 TLB를 함께 사용한다.

---
## 가상 주소와 물리 주소
가상 주소는 CPU와 프로그램이 바라보는 논리적 메모리 주소이고, 물리 주소는 실제 RAM 하드웨어 상의 메모리 위치를 의미한다.<br>
가상 주소는 메모리 관리 장치(MMU)에 의해 물리 주소로 변환되며, 이 과정에서 페이지 테이블과 TLB가 사용된다.<br>
가상 주소를 사용하면 프로세스마다 독립된 주소 공간을 제공할 수 있어 보안성과 안정성이 높아지고, 물리 메모리 크기보다 큰 프로그램도 실행 가능하다.

---
## 페이지 폴트
페이지 폴트는 CPU가 참조하려는 페이지가 물리 메모리에 존재하지 않을 때 발생하는 예외 상황이다.<br>
이 경우 운영체제는 디스크에서 해당 페이즈를 읽어와 메모리에 적재하고, 페이지 테이블을 갱신한 뒤 해당 명령을 다시 실행한다.<br>
페이지 폴트는 가상 메모리 시스템의 정상 동작 과정이지만, 발생 빈도가 높으면 페이지 스래싱으로 이어져 성능이 급격히 저하될 수 있다.

---
## JVM
자바 바이트코드를 실행하기 위한 가상 머신으로, 운영체제와 하드웨어에 독립적으로 프로그램이 동작할 수 있게 한다.

---
## 힙 메모리
JVM의 런타임 데이터 영역 중 하나로, 동적으로 생성된 객체와 배열이 저장되는 공간이다.<br>
힙 메모리는 모든 스레드가 공유하며, 가비지 컬렉터가 사용하지 않는 객체를 제거해 메모리를 회수한다.

---
## 스택 메모리
JVM의 런타임 데이터 영역 중 하나로, 각 스레드마다 독립적으로 생성되며 메서드 호출 시 생성되는 **프레임**을 저장한다.<br>
프레임에는 **지역변수, 매개변수, 연산 스택, 메서드 호출 정보 등**이 포함된다. <br>
메서드가 호출될 때 프레임이 쌓이고, 종료되면 프레임이 제거되는 **LIFO(Last In First Out)** 방식으로 동작한다.<br>
스택 메모리는 접근 속도가 빠르지만 크기가 제한적이며, 너무 깊은 재귀 호출 등으로 초과 사용 시 **StackOverFlowError**가 발생한다.

---
## GC
Garbage Collection은 JVM에서 더 이상 참조되지 않는 객체를 자동으로 메모리에서 해제하는 메커니즘이다.<br>
개발자가 직접 메모리를 해제하지 않아도 되므로 메모리 누수 위험을 줄이고 안정성을 높인다.

---
## OOM
Out of Memory는 JVM이 필요한 메모리를 더 이상 할당할 수 없을 때 발생하는 오류로, OutOfMemoryError가 발생한다. <br>
주로 힙 메모리 부족, 메타스페이스 부족 또는 네이티브 메모리 부족이 원인.

---
## 스왑 공간
스왑 공간은 물리 메모리(RAM)이 부족할 때 디스크의 일부를 메모리처럼 사용하기 위해 예약해 둔 영역.<br>
운영체제는 사용 빈도가 낮은 메모리 페이즈를 스왑 공간으로 옮겨 RAM을 확보하고, 필요해지면 다시 불러온다. 이는 메모라 부족 시 시스템이 멈추지 않게 하지만, 디스크I/O 속도가 RAM보다 훨씬 느려 성능 저하가 발생할 수 있다.

---
## 캐시
캐시는 자주 사용되는 데이터나 연산 결과를 임시로 저장해 다음 접근 시 더 빠르게 제공하는 저장소.<br>
CPU와 메모리 사이의 속도 차이를 줄이기 위해 CPU 캐시를 사용하고, 웹 서비스에서는 DB. API 요청 결과를 메모리에 저장하는 애플리케이션 캐시를 사용한다. <br>
캐시는 **지역성** 원리를 기반으로 하며, **시간 지역성**은 최근 접근한 데이터를, **공간 지역성**은 인접한 데이터를 캐싱한다. <br>
캐시 크기가 안정적이므로 **LRU, LFU, FIFO** 같은 교체 알고리즘이 사용된다.

---
## 지역성
지역성은 프로그램이 메모리를 접근하는 패턴으로, 특정 데이터나 명령어가 짧은 시간 안에 반복적으로 또는 가까운 주소에서 사용되는 성질을 말함. -> 캐시 효율성을 높이는 핵심 원리

---
## 페이징
페이징은 가상 메모리를 고정 크기 블록으로 나누어 관리하는 메모리 관리 기법이다.<br>
가상 메모리에서는 각 블록을 **페이지(Page)** 라고 하고, 물리 메모리에서는 같은 크기의 블록을 **프레임(Frame)** 이라 한다.<br>
프로세스의 페이지는 페이지 테이블을 통해 물리 프레임에 매핑되며, 연속되지 않은 프레임에 저장될 수 있어 **외부 단편화(External Fragmentation)** 를 방지한다.

---
## 세그먼테이션
가상 메모리를 **논리적 단위(세그먼트)** 로 나누어 관리하는 메모리 관리 기법.<br>
세그먼트는 코드, 데이터, 스택 등 의미 있는 블록 단위로 크기가 서로 다를 수 있다. 각 세그면트는 **세그먼트 번호** 와 **오프셋** 의 주소를 표현하며, 세그먼테 테이블을 통해 물리 메모리 주소로 변환된다.

---
## 워킹 셋 모델
워킹 셋 모델은 프로세스가 일정 시간 동안 자주 참조하는 페이지 집합을 **워킹 셋** 이라 정의하고, 이 집합이 메모리에 모두 올라와 있도록 관리하는 메모리 관리 기법이다.

---
## 폴링
CPU나 프로그램이 주기적으로 장치나 상태를 확인해, 작업이 준비되었는지 감시하는 방식.

---
## 커널 모드
커널 모드는 CPU가 운영체제의 핵심 기능을 수행할 수있도록 모든 하드웨어 자원과 명령에 접근할 수 있는 권한 모드.<br>
파일 시스템 접근, 메모리 관리, 프로세스 스케줄링, I/O 제어 등 **특권 명령(Privileged Instructions)** 을 실행할 수 있다.

---
## 사용자 모드
시영지 모드는 CPU가 제한된 권한으로 명령을 실행하는 모드로, 애플리케이션 프로그램이 기본적으로 동작하는 환경이다.<br>
하드웨어 자원이나 특권 명령에는 직접 접근할 수 없으며, 필요할 경우 **시스템 콜**을 통해 커널 모드로 전환해 요청을 처리한다.

---
## LRU
가장 오래 사용되지 않은 데이터를 먼저 교체하는 캐시 교체 알고리즘.<br>
시간 지역성 원리를 기반으로, 최근에 사용된 데이터는 앞으로도 사용될 가능성이 높다고 가정한다.<br>
구현 방법으로는 리스트나 해시 + Liked List를 사용해 데이터 접근 시 순서를 갱신하고, 캐시가 가득 차면 가장 오래된 항목을 제거한다.

---
## LFU
가장 적게 사용된 데이터를 먼저 교체하는 캐시 알고리즘 <br>
시간이 아닌 사용 빈도를 기준으로 하며, 각 데이터의 접근 횟수를 기록하고, 캐시가 가득 차면 접근 횟수가 가장 적은 항목을 제거한다.<br>
운영체제 페이지 교체나 CDN 캐싱에서 사용되지만, 구현 복잡도가 높은 편이다.

---
## FIFO
가장 먼저 들어온 데이터를 가장 먼저 교체하는 캐시 교체 알고리즘 <br>
큐(Queue) 자료구조 원리를 사용하며, 구현이 단순하고 직관적이다.

---
## Optimal
앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식이다.<br>
이론적으로는 페이지 폴트 횟수를 최소화할 수 있어 가장 효율적인 알고리즘이지만, 미래의 메모리 접근 패턴을 알아야 하므로 실제 운영체제에서는 구현이 불가능하다.

---
## 스레싱
페이지 폴트가 과도하게 발생해 CPU가 실제 작업보다 페이지 교체에 더 많은 시간을 소모하는 상태.<br>
주로 물리 메모리가 부족하거나, 동시에 많은 프로세스를 실행해 워킹 셋 크기가 메모리를 초과할 때 발생한다.

---
## 스키마
데이터베이스의 구조와 제약 조건을 정의한 설계도.<br>
테이블, 뷰, 인덱스, 관계, 데이터 타입, 제약 조건 등을 포함한다.<br>
스키마는 데이터베이스의 일관성과 무결성을 유지하는 데 중요한 역할을 하며, 물리적 저장 방식과는 독립적으로 설계된다.

---
## SQL
관계형 데이터베이스에서 데이터를 정의하고 조작하기 위한 표준 언어 <br>
테이블 기반 구조를 사용하며, **스키마(정형 데이터)** 를 강제한다. <br>
주로 명령어로는 DDL, DML, DCL, TCL이 있다.

---
## NoSQL
관계형 모델을 따르지 않는 데이터베이스로 유연한 스키마와 수평 확장성을 지원한다. <br>
Key-Value, Document, Column, Graph 등 다양한 데이터 모델을 제공한다.

---
## 비정형 데이터
고정된 스키마나 정해진 구조가 없는 데이터 형태이다.

---
## JSON
경량 데이터 교환 형식으로 키 - 값 쌍과 계층적 구조를 지원한다. <br>
가독성이 높고 언어 독립적이며, REST API, NoSQL(Document DB) 등에서 널리 사용된다.

---
## Key-Value
키-값 쌍으로 데이터를 저장하는 NoSQL 데이터베이스 모델.<br>
빠른 읽기/쓰기 성능을 제공하며, 캐시 시스템이나 세션 관리 등에 주로 사용된다.

---
## Column
열 기반 저장소로, 데이터를 컬럼 단위로 저장하여 대규모 분석에 최적화된 NoSQL 모델.<br>
대량의 데이터를 빠르게 읽고 쓰는 데 유리하며, 빅데이터 처리에 자주 사용된다.

---
## Graph
노드와 엣지로 데이터를 표현하는 NoSQL 모델.<br>
복잡한 관계와 연결성을 효율적으로 처리하며, 소셜 네트워크, 추천 시스템 등에 활용된다.

---
## B-tree
균형 이진 트리의 일종으로, 데이터베이스와 파일 시스템에서 인덱스를 구현하는 데 사용된다.<br>
높은 검색, 삽입, 삭제 성능을 제공하며, 디스크 I/O를 최소화하도록 설계되었다.

---
## Hash
키를 해시 함수에 입력해 고정된 크기의 해시 값을 생성하고, 이를 인덱스로 사용해 데이터를 저장하는 방식.<br>
빠른 검색 속도를 제공하지만, 충돌 해결과 메모리 사용량 관리가 필요하다.

---
## READ UNCOMMITTED
가장 낮은 격리 수준으로, 한 트랜잭션이 커밋되지 않은 변경 사항을 다른 트랜잭션이 읽을 수 있다.<br>
더티 리드(Dirty Read)가 발생할 수 있어 데이터 일관성이 낮다.

---
## READ COMMITTED
커밋된 데이터만 읽을 수 있는 격리 수준으로, 더티 리드가 방지된다.<br>
하지만 반복 읽기(Non-Repeatable Read)와 팬텀 리드(Phantom Read)는 발생할 수 있다.

---
## REPEATABLE READ
한 트랜잭션 내에서 동일한 쿼리를 여러 번 실행해도 같은 결과를 보장하는 격리 수준.<br>
더티 리드와 반복 읽기가 방지되지만, 팬텀 리드는 여전히 발생할 수 있다.

---
## SERIALIZABLE
가장 높은 격리 수준으로, 모든 트랜잭션이 순차적으로 실행되는 것처럼 동작한다.<br>
더티 리드, 반복 읽기, 팬텀 리드가 모두 방지되지만, 동시성이 크게 저하될 수 있다

